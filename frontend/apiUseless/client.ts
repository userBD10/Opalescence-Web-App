// DO NOT EDIT THIS FILE

import {
  APITemplate,
  ClientMutations,
  ClientQueries,
  InferHandlerInput,
  MutationPaths,
  QueryPaths,
} from '@/apiUseless/types'
import {
  InvalidateOptions,
  InvalidateQueryFilters,
  QueryClient,
  QueryKey,
  useMutation as __useMutation,
  UseMutationOptions,
  UseMutationResult,
  useQuery as __useQuery,
  UseQueryOptions,
} from '@tanstack/react-query'

export class API<const APISchema extends APITemplate> {
  public queryClient: QueryClient

  private contract: APISchema

  /**
   * Initializes a new instance of the class with the provided API schema.
   *
   * @param {APISchema} contract - The API schema used to initialize the instance.
   */
  constructor(contract: APISchema) {
    this.queryClient = new QueryClient()
    this.contract = contract
  }

  /**
   * Returns a function that throws an error with the provided API error.
   *
   * @param {any} apiError - The API error to be thrown.
   * @throws {object} - An object containing the API error.
   */
  private validateApiError() {
    return (apiError: any) => {
      throw { apiError }
    }
  }

  /**
   * Executes a query using the specified path and input.
   *
   * @param {[path: TPath, args: TQueryInput]} pathAndInput - The path and input for the query.
   * @param {UseQueryOptions<TQueryOutput>} [opts] - The options for the query.
   * @returns {Promise<TQueryOutput>} - A promise that resolves to the query output.
   */
  public useQuery<
    TPath extends QueryPaths<APISchema> & string,
    TQueryOutput extends ClientQueries<APISchema>[TPath]['awaitedResponse'],
    TQueryInput extends InferHandlerInput<APISchema[TPath]>
  >(pathAndInput: [path: TPath, args: TQueryInput], opts?: UseQueryOptions<TQueryOutput>) {
    const [path, args] = pathAndInput
    const endpoint = this.contract[path]

    return __useQuery(
      pathAndInput as QueryKey,
      () => endpoint(args).catch(this.validateApiError()),
      opts
    )
  }

  /**
   * A function that allows the usage of a mutation.
   *
   * @param {TPath | [TPath]} path - The path or array of paths for the mutation.
   * @param {UseMutationOptions<TMutationOutput, unknown, TMutationInput>} opts - Optional options for the mutation.
   * @return {UseMutationResult<TMutationOutput, unknown, TMutationInput>} The result of the mutation.
   */
  public useMutation<
    TPath extends MutationPaths<APISchema> & string,
    TMutationOutput extends ClientMutations<APISchema>[TPath]['awaitedResponse'],
    TMutationInput extends InferHandlerInput<APISchema[TPath]>
  >(
    path: [TPath] | TPath,
    opts?: UseMutationOptions<TMutationOutput, unknown, TMutationInput>
  ): UseMutationResult<TMutationOutput, unknown, TMutationInput> {
    const actualPath = Array.isArray(path) ? path[0] : path
    const endpoint = this.contract[actualPath]

    return __useMutation(
      (input: TMutationInput) => endpoint(input).catch(this.validateApiError()),
      opts
    )
  }

  /**
   * Invalidates queries based on the provided filters and options.
   *
   * @param {InvalidateQueryFilters & { queryKey: [path: TPath, args: Partial<TQueryInput>] }} filters - The filters to apply when invalidating queries.
   * @param {InvalidateOptions} [options] - The options to customize the invalidation behavior.
   * @return {Promise<void>} A promise that resolves when the queries are invalidated.
   */
  public invalidateQueries<
    TPath extends QueryPaths<APISchema> & string,
    TQueryInput extends InferHandlerInput<APISchema[TPath]>
  >(
    filters: InvalidateQueryFilters & { queryKey: [path: TPath, args: Partial<TQueryInput>] },
    options?: InvalidateOptions
  ) {
    return this.queryClient.invalidateQueries(filters, options)
  }
}
